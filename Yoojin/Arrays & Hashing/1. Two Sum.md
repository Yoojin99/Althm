# 1. Two Sum

```swift
import Foundation


class Solution {
    // 아이디어 2
    /*
     dictionary 를 사용해서 [숫자: 인덱스] 를 저장함
     배열을 한 번만 훑으면서 target - num = left, left 가 딕셔너리에 있는지 검사하면 됨
     
     time : O(N)
     space : O(N)
     */
    // 15ms, 16.33 왜 더 오래걸리는겨
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        // 숫자 : 인덱스
        var numDict = [Int:Int]()
        
        for (numIndex, num) in nums.enumerated() {
            let findNumber = target - num
            
            if let findNumberIndex = numDict[findNumber] {
                return [numIndex, findNumberIndex]
            }
            
            numDict[num] = numIndex
        }
        
        return []
    }
    
    // 아이디어 1
    /*
     먼저 배열을 정렬 O(NlogN) 10^4 * 4 -> 큰 문제 안될 듯
     앞에서부터 훑고, 뒤에서부터 훑기 O(N)
     더한 값이 작으면 앞 커서 움직이고 더한 값이 크면 뒤 커서 움직임
     
     time : O(N)
     space : O(N) - sorted()
     */
    
    // nums 내 두 숫자를 더해서 target 이 되는 경우의 index
    // 오직 한 개의 답만 존재
    // 같은 요소를 두 번 사용 불가
    // 답 순서는 노상관
    // 19ms, 16.48MB
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        let enumeratedNums = nums.enumerated()
        let sortedNums = enumeratedNums.sorted { lhs, rhs in
            return lhs.element < rhs.element
        }
        
        var smallIndex = 0, bigIndex = nums.count - 1
        
        while smallIndex < bigIndex {
            let small = sortedNums[smallIndex]
            let big = sortedNums[bigIndex]
            
            let sum = small.element + big.element
            
            if sum == target {
                return [small.offset, big.offset]
            } else if sum > target {
                bigIndex -= 1
            } else {
                smallIndex += 1
            }
        }
        
        return []
    }
}
```