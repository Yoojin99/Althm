### 242. Valid Anagrams

```swift
// 아이디어 1
/*
 단어마다 문자의 등장 횟수를 세서 s와 t를 비교
 s.length = N
 t.length = M
 
 O(N+M)
 
 s 먼저 훑고 t 를 훑으면서 조건에 위배하면 early return 을 하면 조금 더 빠르지 않을까? -> 아님

 */
 import Foundation

class Solution {
    func getLettersCount(string: String) -> [Character:Int] {
        var result = [Character:Int]()
        
        for letter in string {
            result[letter, default: 0] += 1
        }
        
        return result
    }

    // true : t가 s의 anagram
    // anagram : 단어 순서만을 바꿔서 생성할 수 있는 단어/문구
    // 15ms / 16.44MB
    // time : O(N) 문자열 길이만큼 한 번씩 훑으면 됨
    // space : O(K) K는 문자열에서 unique 하게 존재하는 글자 수
    func isAnagram(_ s: String, _ t: String) -> Bool {
        let sLettersCount = getLettersCount(string: s)
        let tLettersCount = getLettersCount(string: t)
        

        guard sLettersCount.count == tLettersCount.count else {
            return false
        }
        
        return sLettersCount.allSatisfy { (sLetter, sLetterCount) in
            sLetterCount == tLettersCount[sLetter]
        }
    }
    
    // 25ms / 16.44MB
    // 오히려 early return 하는게 더 오래 걸리네?
    func isAnagram(_ s: String, _ t: String) -> Bool {
        guard s.count == t.count else {
            return false
        }
        
        var sLettersCount = getLettersCount(string: s)
        
        for tLetter in t {
            guard let sLetterCount = sLettersCount[tLetter],
                  sLetterCount > 0 else {
                return false
            }
            
            sLettersCount[tLetter]! -= 1
        }
        
        return sLettersCount.allSatisfy { $0.value == 0 }
    }
}
```
